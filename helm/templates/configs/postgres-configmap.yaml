apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-init
  namespace: voting-data
  labels:
    app.kubernetes.io/name: voting-app
    app.kubernetes.io/component: database
    app.kubernetes.io/part-of: voting-system
    app.kubernetes.io/managed-by: helm
data:
  01-init-schema.sql: |
    -- Voting application database schema
    -- Creates tables for Cats vs Dogs voting system

    -- Votes table: stores aggregated vote counts
    CREATE TABLE IF NOT EXISTS votes (
        id SERIAL PRIMARY KEY,
        option VARCHAR(10) NOT NULL CHECK (option IN ('cats', 'dogs')),
        count INTEGER NOT NULL DEFAULT 0,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );

    -- Create unique constraint to ensure only one row per option
    CREATE UNIQUE INDEX IF NOT EXISTS idx_votes_option ON votes(option);

    -- Initialize vote counts for both options
    INSERT INTO votes (option, count)
    VALUES
        ('cats', 0),
        ('dogs', 0)
    ON CONFLICT (option) DO NOTHING;

    -- Vote events table: audit log of all individual votes (optional)
    CREATE TABLE IF NOT EXISTS vote_events (
        id SERIAL PRIMARY KEY,
        option VARCHAR(10) NOT NULL CHECK (option IN ('cats', 'dogs')),
        timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        source_ip INET,
        user_agent TEXT
    );

    -- Index for querying vote events by timestamp
    CREATE INDEX IF NOT EXISTS idx_vote_events_timestamp ON vote_events(timestamp DESC);
    CREATE INDEX IF NOT EXISTS idx_vote_events_option ON vote_events(option);

    -- Grant permissions to application user (will be created via secrets)
    -- Note: User creation handled by POSTGRES_USER env var
    GRANT SELECT, INSERT, UPDATE ON votes TO CURRENT_USER;
    GRANT SELECT, INSERT ON vote_events TO CURRENT_USER;
    GRANT USAGE, SELECT ON SEQUENCE votes_id_seq TO CURRENT_USER;
    GRANT USAGE, SELECT ON SEQUENCE vote_events_id_seq TO CURRENT_USER;

  02-create-functions.sql: |
    -- Function to increment vote count atomically
    CREATE OR REPLACE FUNCTION increment_vote(vote_option VARCHAR(10))
    RETURNS TABLE(option VARCHAR(10), new_count INTEGER) AS $$
    BEGIN
        -- Validate input
        IF vote_option NOT IN ('cats', 'dogs') THEN
            RAISE EXCEPTION 'Invalid vote option: %. Must be cats or dogs', vote_option;
        END IF;

        -- Increment vote count atomically
        UPDATE votes
        SET
            count = count + 1,
            updated_at = NOW()
        WHERE votes.option = vote_option
        RETURNING votes.option, votes.count INTO option, new_count;

        -- Return updated values
        RETURN NEXT;
    END;
    $$ LANGUAGE plpgsql;

    -- Function to get current vote results
    CREATE OR REPLACE FUNCTION get_vote_results()
    RETURNS TABLE(
        option VARCHAR(10),
        count INTEGER,
        percentage NUMERIC(5,2),
        updated_at TIMESTAMP WITH TIME ZONE
    ) AS $$
    DECLARE
        total_votes INTEGER;
    BEGIN
        -- Calculate total votes
        SELECT SUM(votes.count) INTO total_votes FROM votes;

        -- Return results with percentages
        RETURN QUERY
        SELECT
            votes.option,
            votes.count,
            CASE
                WHEN total_votes > 0 THEN ROUND((votes.count::NUMERIC / total_votes * 100), 2)
                ELSE 0.00
            END AS percentage,
            votes.updated_at
        FROM votes
        ORDER BY votes.count DESC;
    END;
    $$ LANGUAGE plpgsql;
